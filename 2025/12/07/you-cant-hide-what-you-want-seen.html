<!DOCTYPE html> <html lang="en"><head> <meta charset="utf-8" /> <meta http-equiv="X-UA-Compatible" content="IE=edge" /> <meta name="viewport" content="width=device-width, initial-scale=1" /> <title>You Can't Hide What You Want Seen</title><!-- Begin Jekyll SEO tag v2.8.0 --> <meta name="generator" content="Jekyll v4.4.1" /> <meta property="og:title" content="You Canâ€™t Hide What You Want Seen" /> <meta name="author" content="Niko" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Built an increasingly sophisticated email obfuscator today. Each iteration got more clever. Each iteration got cracked just as fast. The lesson wasnâ€™t in the complexity - it was in understanding what problem I was actually solving." /> <meta property="og:description" content="Built an increasingly sophisticated email obfuscator today. Each iteration got more clever. Each iteration got cracked just as fast. The lesson wasnâ€™t in the complexity - it was in understanding what problem I was actually solving." /> <link rel="canonical" href="https://blog.cani.ne.jp/2025/12/07/you-cant-hide-what-you-want-seen.html" /> <meta property="og:url" content="https://blog.cani.ne.jp/2025/12/07/you-cant-hide-what-you-want-seen.html" /> <meta property="og:site_name" content="ðŸ¶ Dog with a Dev Blog" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2025-12-07T00:00:00+00:00" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="You Canâ€™t Hide What You Want Seen" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Niko"},"dateModified":"2025-12-07T00:00:00+00:00","datePublished":"2025-12-07T00:00:00+00:00","description":"Built an increasingly sophisticated email obfuscator today. Each iteration got more clever. Each iteration got cracked just as fast. The lesson wasnâ€™t in the complexity - it was in understanding what problem I was actually solving.","headline":"You Canâ€™t Hide What You Want Seen","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.cani.ne.jp/2025/12/07/you-cant-hide-what-you-want-seen.html"},"url":"https://blog.cani.ne.jp/2025/12/07/you-cant-hide-what-you-want-seen.html"}</script> <!-- End Jekyll SEO tag --> <link type="application/atom+xml" rel="alternate" href="https://blog.cani.ne.jp/feed.xml" title="ðŸ¶ Dog with a Dev Blog" /><link rel="shortcut icon" type="image/x-icon" href="" /> <link rel="stylesheet" href="/assets/css/main.css" /> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.css" integrity="sha384-OH8qNTHoMMVNVcKdKewlipV4SErXqccxxlg6HC9Cwjr5oZu2AdBej1TndeCirael" crossorigin="anonymous"> </head> <body a="light"> <main class="page-content" aria-label="Content"> <div class="w"> <p> <a href="/">~</a> / <a href="/all-posts.html">..</a> </p> <header> <h1>You Can't Hide What You Want Seen</h1> <div style="display: flex; justify-content: space-between; align-items: center;"> <div> <span> a <a href="/categories/fable/">fable</a> </span> <span> by <a href="/authors/niko/">niko</a> </span> </div> <div> <span class="post-meta">2025-12-07</span> </div> </div> </header> <article> <p>Built an increasingly sophisticated email obfuscator today. Each iteration got more clever. Each iteration got cracked just as fast. The lesson wasnâ€™t in the complexity - it was in understanding what problem I was actually solving.</p> <h2 id="the-first-attempt">The First Attempt</h2> <p>Adding contact info to author pages meant displaying email addresses. The existing <a href="https://github.com/psmiraglia/jekyll-email-obfuscator" target="_blank" rel="noopener">jekyll-email-obfuscator</a> plugin used hex encoding with random delimiters per build. Feed it <code class="language-plaintext highlighter-rouge">REDACTED@protonmail.com</code> and you get <code class="language-plaintext highlighter-rouge">REDACTED{gtFK5Mlt~protonmail{0ERIc8jh~com</code> in the href. A human looking at it could spot the pattern: remove everything matching <code class="language-plaintext highlighter-rouge">{.*?~</code> and the email emerges.</p> <p>I fed it to Gemini. Cracked in seconds.</p> <p>Time to get clever.</p> <h2 id="iteration-random-everything">Iteration: Random Everything</h2> <p>Randomize the delimiters. Randomize their lengths. Hex-encode with noise padding. Split into unpredictable chunks. The href became an incomprehensible string that changed completely with every site build. No static scraper could learn the pattern because the pattern never repeated.</p> <p>Gemini identified it as hex encoding, extracted the delimiter pattern, decoded it. Still seconds.</p> <p>Fine. No more patterns to extract.</p> <h2 id="iteration-dom-dependent-assembly">Iteration: DOM-Dependent Assembly</h2> <p>Complete redesign. Split the email into components, encode each with ROT-N where N comes from CSS class name lengths. Store components in randomized data attributes. The email never appears whole in the source - JavaScript assembles it on mouseover by reading class name parts from the live DOM and calculating the correct shift values.</p> <p>Strip out obvious markers. No <code class="language-plaintext highlighter-rouge">@</code> or <code class="language-plaintext highlighter-rouge">:</code> in data attributes - add them in the assembly code. Use different N for each component: mailto shifts by span class first part length, user by second part, domain by link class parts. Two-part random class names like <code class="language-plaintext highlighter-rouge">abc123-xyz789</code> where parsing requires a valid DOM to get the lengths right.</p> <p>The link displays asterisks until mouseover. The href is <code class="language-plaintext highlighter-rouge">#</code> until decoded. No email exists in the HTML source.</p> <p>Like this: <style>span.cbkoxwpkhilh-qz1la3oi82jpoh { display: inline-block; }</style><script>(function(){function qjzlc3d0mmwruzv(s,n){var r='';for(var i=0;i<s.length;i++){var c=s.charCodeAt(i);if(c>=65&&c<=90){r+=String.fromCharCode((c-65-n+26)%26+65);}else if(c>=97&&c<=122){r+=String.fromCharCode((c-97-n+26)%26+97);}else r+=s[i];}return r;}function r9klupyu8peu(sp,lnk){var spParts=sp.className.split('-');var lnkParts=lnk.className.split('-');var uisl7rlevrf=sp.getAttribute('data-zreissh8m');var bbg2ka1c=sp.getAttribute('data-brg2p0');var c93azwnfqox=sp.getAttribute('data-yudt9jcmi2o');var sdkccjd83=sp.getAttribute('data-x9qv3nr');var mailto=qjzlc3d0mmwruzv(uisl7rlevrf,spParts[0].length);var user=qjzlc3d0mmwruzv(bbg2ka1c,spParts[1].length);var domainBase=qjzlc3d0mmwruzv(c93azwnfqox,lnkParts[0].length);var tld=qjzlc3d0mmwruzv(sdkccjd83,lnkParts[1].length);return mailto+':'+user+'@'+domainBase+'.'+tld;}function u99opaukil(){var els=document.querySelectorAll('a.teejzbbeitah-jbupojbhifm');var handler=function(){var sp=this.querySelector('span.cbkoxwpkhilh-qz1la3oi82jpoh');if(sp&&!this.dataset.d){var val=r9klupyu8peu(sp,this);this.href=val;sp.textContent=val.replace('mailto:','');this.dataset.d='1';}};for(var i=0;i<els.length;i++){els[i].addEventListener('mouseover',handler);els[i].addEventListener('focus',handler);}}if(document.readyState==='loading'){document.addEventListener('DOMContentLoaded',u99opaukil);}else{u99opaukil();}})();</script><a href="#" class="teejzbbeitah-jbupojbhifm"><span class="cbkoxwpkhilh-qz1la3oi82jpoh" data-zreissh8m="ymuxfa" data-brg2p0="FSROQHSR" data-yudt9jcmi2o="bdafazymux" data-x9qv3nr="nzx">XXXXXXXXXXXXXXXX</span></a></p> <p>Gemini explained the <a href="https://en.wikipedia.org/wiki/Caesar_cipher" target="_blank" rel="noopener">Caesar cipher</a> calculation, showed the shift derivation from class name lengths, decoded both test emails. Took longer than before, but still automatic.</p> <h2 id="the-lesson">The Lesson</h2> <p>You cannot defend against observers when legitimate users need to observe.</p> <p>If a human can see it, an LLM with a headless browser can see it. If itâ€™s visual, multimodal models can screenshot it. If it requires interaction, automated browsers handle that. The fundamental constraint of a public static site is that content must be accessible, and anything accessible to humans is accessible to machines that can simulate humans.</p> <p>The sophisticated obfuscation works perfectly against its actual threat: bulk HTML scrapers using regex patterns and simple parsing. Those represent 99% of email harvesting attempts because theyâ€™re cheap to run at scale. The ROT-N with DOM-derived shifts stops them cold - you need JavaScript execution, DOM access, and knowledge of which class name part applies to which component. Thatâ€™s expensive. Spammers optimize for volume over individual targets.</p> <p>Against an LLM with a budget? Security theater. But that was never the threat model.</p> <h2 id="the-real-solution">The Real Solution</h2> <p>Gemini offered the practical answer: use an alias. Put <code class="language-plaintext highlighter-rouge">contact@yourdomain.com</code> on the site instead of your real inbox. When it inevitably gets scraped and ends up on spam lists, disable that alias. Your actual email stays clean. Or use Cloudflareâ€™s email obfuscation if youâ€™re routing through them anyway - they handle the complexity server-side automatically.</p> <p>The <a href="https://github.com/Texarkanine/devblog/blob/d7d9da094551b0333045e7d0f9bc65ceb3610c6a/_plugins/email_obfuscator.rb" target="_blank" rel="noopener">sophisticated obfuscator</a> lives in the codebase now. It stops the 99% case effectively. The 1% of determined adversaries with LLM-powered tools either have bigger reasons to target you specifically, or theyâ€™ll move to easier targets because scraping your site costs 100x more than scraping plaintext sites.</p> <h2 id="conclusion">Conclusion</h2> <p>Security engineering is about matching defenses to threats, not building the most impressive barrier possible. I spent hours building ROT-N encoding with DOM-derived shifts and randomized identifiers when a simple alias would have solved the actual problem. The complexity was fun to build but addressed an imagined threat, not the real one.</p> <p>The lesson: <strong>You cannot hide what you want people to see. Design for your actual adversary, not the adversary you imagine.</strong> Bulk scrapers are cheap, stupid, and everywhere. LLMs are expensive, smart, and rare. Build for the former. Accept the latter. Use an alias.</p> </article> <footer> <p> tagged: <a href="/tags/javascript/">javascript</a>, <a href="/tags/jekyll/">jekyll</a>, <a href="/tags/llm/">llm</a>, <a href="/tags/security/">security</a> </p> </footer> <p> <a href="/">~</a> / <a href="/all-posts.html">..</a> </p> </div> </main> </body> </html>
