<!DOCTYPE html> <html lang="en"><head> <meta charset="utf-8" /> <meta http-equiv="X-UA-Compatible" content="IE=edge" /> <meta name="viewport" content="width=device-width, initial-scale=1" /> <title>Two Jekyll Image Plugins</title><!-- Begin Jekyll SEO tag v2.8.0 --> <meta name="generator" content="Jekyll v4.4.1" /> <meta property="og:title" content="Two Jekyll Image Plugins" /> <meta name="author" content="Niko" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Built two custom Jekyll plugins today to handle images in blog posts. What started as ‚ÄúI don‚Äôt want to type the full path‚Äù turned into an exercise in keeping things simple." /> <meta property="og:description" content="Built two custom Jekyll plugins today to handle images in blog posts. What started as ‚ÄúI don‚Äôt want to type the full path‚Äù turned into an exercise in keeping things simple." /> <link rel="canonical" href="https://blog.cani.ne.jp/2025/11/25/two-jekyll-image-plugins.html" /> <meta property="og:url" content="https://blog.cani.ne.jp/2025/11/25/two-jekyll-image-plugins.html" /> <meta property="og:site_name" content="üê∂ Dog with a Dev Blog" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2025-11-25T00:00:00+00:00" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="Two Jekyll Image Plugins" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Niko"},"dateModified":"2025-11-25T00:00:00+00:00","datePublished":"2025-11-25T00:00:00+00:00","description":"Built two custom Jekyll plugins today to handle images in blog posts. What started as ‚ÄúI don‚Äôt want to type the full path‚Äù turned into an exercise in keeping things simple.","headline":"Two Jekyll Image Plugins","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.cani.ne.jp/2025/11/25/two-jekyll-image-plugins.html"},"url":"https://blog.cani.ne.jp/2025/11/25/two-jekyll-image-plugins.html"}</script> <!-- End Jekyll SEO tag --> <link type="application/atom+xml" rel="alternate" href="https://blog.cani.ne.jp/feed.xml" title="üê∂ Dog with a Dev Blog" /><link rel="shortcut icon" type="image/x-icon" href="" /> <link rel="stylesheet" href="/assets/css/main.css" /> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.css" integrity="sha384-OH8qNTHoMMVNVcKdKewlipV4SErXqccxxlg6HC9Cwjr5oZu2AdBej1TndeCirael" crossorigin="anonymous"> </head> <body a="light"> <main class="page-content" aria-label="Content"> <div class="w"> <p> <a href="/">~</a> / <a href="/all-posts.html">..</a> </p> <header> <h1>Two Jekyll Image Plugins</h1> <div style="display: flex; justify-content: space-between; align-items: center;"> <div> <span> a <a href="/categories/diary/">diary</a> </span> <span> by <a href="/authors/niko/">niko</a> </span> </div> <div> <span class="post-meta">2025-11-25</span> </div> </div> </header> <article> <p>Built two custom Jekyll plugins today to handle images in blog posts. What started as ‚ÄúI don‚Äôt want to type the full path‚Äù turned into an exercise in keeping things simple.</p> <h2 id="the-initial-problem">The Initial Problem</h2> <p>I had a post in <code class="language-plaintext highlighter-rouge">blog/record/_posts/</code> with an image reference:</p> <div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">![</span><span class="nv">Look at this dog</span><span class="p">](</span><span class="sx">/blog/record/thisdog.jpg</span><span class="p">)</span>
</code></pre></div></div> <p>That <code class="language-plaintext highlighter-rouge">/blog/record/</code> path felt redundant - the post already lives in that directory. Why repeat myself? Plus, we had <code class="language-plaintext highlighter-rouge">jekyll-images-cdn</code> for prepending CDN URLs, which was working fine for local development with <code class="language-plaintext highlighter-rouge">/assets/img</code>. We had already shaved <em>that</em> prefix off, why couldn‚Äôt we shave off the rest of the prefix?</p> <h2 id="first-solution-image_pathsrb">First Solution: image_paths.rb</h2> <p>Built a plugin that:</p> <ol> <li>Extracts the post‚Äôs directory from its path</li> <li>Resolves relative image paths (like <code class="language-plaintext highlighter-rouge">thisdog.jpg</code>) to that directory</li> <li>Applies CDN configuration from <code class="language-plaintext highlighter-rouge">_config.yaml</code></li> </ol> <p>So now I can write <code class="language-plaintext highlighter-rouge">![Dog](thisdog.jpg)</code> and get <code class="language-plaintext highlighter-rouge">/assets/img/blog/record/thisdog.jpg</code>. Perfect. Removed <code class="language-plaintext highlighter-rouge">jekyll-images-cdn</code> since we integrated that functionality directly.</p> <h2 id="the-second-problem">The Second Problem</h2> <p>I have a tall, narrow image that was filling 100% width and dominating the page. I wanted dimension control. Found that some Markdown processors support extended syntax like:</p> <div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">![</span><span class="nv">Image</span><span class="p">](</span><span class="sx">photo.jpg</span> =300x200)
</code></pre></div></div> <p>Nice! Let‚Äôs add that.</p> <h2 id="one-plugin-or-two">One Plugin or Two?</h2> <p>Should this be in the same plugin or separate? I initially thought ‚Äúthey both process images, combine them!‚Äù But after thinking it through:</p> <p><strong>Arguments for combining:</strong></p> <ul> <li>Same <code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> target</li> <li>One regex pass</li> <li>Fewer files</li> </ul> <p><strong>Arguments for separating:</strong></p> <ul> <li>Single Responsibility Principle</li> <li>Different concerns: functional (path resolution) vs presentational (styling)</li> <li>Different hook points (sizing needs pre_render to parse Markdown, paths work post_render on HTML)</li> <li>Different configs</li> <li>Independently useful</li> </ul> <p><strong>Decision: Separate.</strong> Path resolution is infrastructure; sizing is aesthetic preference. Keep ‚Äòem apart.</p> <h2 id="building-image_sizingrb">Building image_sizing.rb</h2> <p>The implementation was‚Ä¶ educational.</p> <h3 id="challenge-1-comment-markers">Challenge 1: Comment Markers</h3> <p>The approach: parse <code class="language-plaintext highlighter-rouge">![alt](url =WIDTHxHEIGHT)</code> in <code class="language-plaintext highlighter-rouge">pre_render</code>, inject an HTML comment marker, then process it in <code class="language-plaintext highlighter-rouge">post_render</code>.</p> <p>First attempt: Used <code class="language-plaintext highlighter-rouge">=WIDTHxHEIGHT</code> as the marker format. Problem: Regex parsing got confused when splitting on ‚Äòx‚Äô.</p> <p>Fixed: Changed to <code class="language-plaintext highlighter-rouge">:</code> separators in the comment: <code class="language-plaintext highlighter-rouge">&lt;!-- IMG_SIZE:300:200:hr --&gt;</code></p> <h3 id="challenge-2-paragraph-wrapping">Challenge 2: Paragraph Wrapping</h3> <p>Jekyll wraps some images in <code class="language-plaintext highlighter-rouge">&lt;p&gt;</code> tags, some not. The regex needed to handle both:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">/&lt;p&gt;)?&lt;img\s+([^&gt;]*)&gt;&lt;!-- IMG_SIZE:... --&gt;(&lt;\/p&gt;)?/</span>
</code></pre></div></div> <p>Capture the paragraph tags, preserve them in output.</p> <h3 id="challenge-3-code-blocks">Challenge 3: Code Blocks</h3> <p>The plugin was processing image syntax everywhere, including inside code fences and inline code blocks. So examples like <code class="language-plaintext highlighter-rouge">![alt](url =300x200)</code> were getting transformed into <code class="language-plaintext highlighter-rouge">![alt](url)&lt;!-- IMG_SIZE:... --&gt;</code> in the rendered output, which I discovered when I wrote them for this post!</p> <p>Fixed: Track code fence state line by line, and split each line by backticks to track inline code state. Only process image syntax when outside both.</p> <p>The logic handles triple-backtick fences, tilde fences, and inline backticks. About 30 lines of careful state tracking, but now code examples stay untouched.</p> <h3 id="challenge-4-the-horizontal-rules-feature">Challenge 4: The Horizontal Rules Feature</h3> <p>Initial plan: When height is specified in pixels, wrap with <code class="language-plaintext highlighter-rouge">&lt;hr&gt;</code> tags for visual emphasis.</p> <p>Implemented it. Worked great! Images with height got horizontal rules above and below.</p> <p>Then realized: This only triggered when BOTH width and height were specified, not just height alone. The logic was getting complex. And honestly, did I really want automatic HRs?</p> <p><strong>Decision: Kill the feature.</strong> Let users add <code class="language-plaintext highlighter-rouge">---</code> in their Markdown if they want horizontal rules. Plugin should just do sizing.</p> <p>Removed ~15 lines of HR logic. Much cleaner.</p> <h3 id="challenge-5-auto-linking">Challenge 5: Auto-Linking</h3> <p>After getting sizing working, realized it would be nice if sized images automatically linked to their full resolution. Click the thumbnail, see the full image in a new tab.</p> <p>But what if an image is already inside a link? Like <code class="language-plaintext highlighter-rouge">[text ![img](url =300x) more](example.com)</code>. Don‚Äôt want to create nested anchors - the inner link would win and break the outer link.</p> <p><strong>Solution:</strong> Detect if image is already inside an anchor tag. In the second pass of <code class="language-plaintext highlighter-rouge">post_render</code>, after applying sizing:</p> <ol> <li>Find images with width/height attributes</li> <li>Scan backwards from the image position</li> <li>Find the last <code class="language-plaintext highlighter-rouge">&lt;a&gt;</code> and <code class="language-plaintext highlighter-rouge">&lt;/a&gt;</code> tags before the image</li> <li>If there‚Äôs an unclosed <code class="language-plaintext highlighter-rouge">&lt;a&gt;</code> ‚Üí inside anchor ‚Üí skip</li> <li>Otherwise ‚Üí wrap in <code class="language-plaintext highlighter-rouge">&lt;a href="src" target="_blank" rel="noopener"&gt;</code></li> </ol> <p>The regex <code class="language-plaintext highlighter-rouge">/&lt;a[\s&gt;]/</code> avoids matching <code class="language-plaintext highlighter-rouge">&lt;article&gt;</code> and <code class="language-plaintext highlighter-rouge">&lt;aside&gt;</code> tags. Used <code class="language-plaintext highlighter-rouge">rindex</code> to find the most recent occurrence, which is simpler than counting all anchors in the page.</p> <p>Added <code class="language-plaintext highlighter-rouge">target="_blank"</code> so full images open in new tab, and <code class="language-plaintext highlighter-rouge">rel="noopener"</code> for security.</p> <p>Tested with images inside text links, standalone sized images, and unsized images. All work correctly.</p> <h2 id="the-final-result">The Final Result</h2> <p>Two plugins, each doing one thing well:</p> <ol> <li><strong>image_paths.rb</strong>: Resolves relative paths based on post location, applies CDN config</li> <li><strong>image_sizing.rb</strong>: Parses <code class="language-plaintext highlighter-rouge">=WIDTHxHEIGHT</code> syntax, applies dimensions</li> </ol> <p>Usage:</p> <div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">![</span><span class="nv">Dog</span><span class="p">](</span><span class="sx">thisdog.jpg</span> =x400)
</code></pre></div></div> <p>Output:</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"/assets/img/blog/record/thisdog.jpg"</span> <span class="na">target=</span><span class="s">"_blank"</span> <span class="na">rel=</span><span class="s">"noopener"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">"/assets/img/blog/record/thisdog.jpg"</span> <span class="na">alt=</span><span class="s">"Dog"</span> <span class="na">height=</span><span class="s">"400"</span><span class="nt">&gt;</span>
<span class="nt">&lt;/a&gt;</span>
</code></pre></div></div> <p>Sized images auto-link to full resolution. Unsized images stay plain. Images already inside links don‚Äôt get double-wrapped.</p> <p>Both plugins run independently in sequence. No coupling. No complexity.</p> <h2 id="what-i-learned">What I Learned</h2> <p><strong>Separate concerns early.</strong> Even if plugins process the same elements, if they serve different purposes, split them.</p> <p><strong>Feature creep happens, but not all features are equal.</strong> The HR feature added complexity for marginal benefit (I can add <code class="language-plaintext highlighter-rouge">---</code> myself). But auto-linking sized images to full resolution? That‚Äôs genuinely useful every time, and the complexity is justified. Know the difference.</p> <p><strong>Debug output matters.</strong> Added <code class="language-plaintext highlighter-rouge">puts</code> statements to see exactly what the regex was capturing. Crucial for debugging that <code class="language-plaintext highlighter-rouge">:</code> vs <code class="language-plaintext highlighter-rouge">x</code> separator issue.</p> <p><strong>Test with real content.</strong> Created test posts with all the edge cases (width only, height only, both, neither). Caught several regex bugs this way.</p> <p><strong>HTML comments as data carriers work well.</strong> Injecting structured comments in <code class="language-plaintext highlighter-rouge">pre_render</code> then parsing them in <code class="language-plaintext highlighter-rouge">post_render</code> bridged the Markdown‚ÜíHTML transformation cleanly.</p> <p><strong>Simple is better.</strong> The final versions are ~50-75 lines each (well, image_sizing grew to ~150 with the linking feature), well-documented, with no clever tricks. Exactly what I wanted.</p> <p><strong>State tracking isn‚Äôt scary.</strong> The code fence detection and anchor detection both required tracking state (are we inside something?). The logic is straightforward: find the last opening/closing pair, compare positions.</p> <h2 id="whats-next">What‚Äôs Next?</h2> <p>Nothing. These plugins are done. They solve the problems I had, nothing more. And that‚Äôs exactly right.</p> <p>Now back to writing actual blog posts instead of building infrastructure for them‚Ä¶</p> </article> <footer> <p> tagged: <a href="/tags/jekyll/">jekyll</a>, <a href="/tags/ruby/">ruby</a>, <a href="/tags/markdown/">markdown</a> </p> </footer> <p> <a href="/">~</a> / <a href="/all-posts.html">..</a> </p> </div> </main> </body> </html>
