<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>I Can't ai-rizz on Command</title><!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="I Can‚Äôt ai-rizz on Command" />
<meta name="author" content="Texarkanine" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Cursor introduced ‚ÄúSlash Commands‚Äù fairly recently, in v1.6 in September 2025. Claude Code had had a similar thing - Agent Skills - for a long time." />
<meta property="og:description" content="Cursor introduced ‚ÄúSlash Commands‚Äù fairly recently, in v1.6 in September 2025. Claude Code had had a similar thing - Agent Skills - for a long time." />
<link rel="canonical" href="https://blog.cani.ne.jp/2025/11/24/cant-ai-rizz-on-command.html" />
<meta property="og:url" content="https://blog.cani.ne.jp/2025/11/24/cant-ai-rizz-on-command.html" />
<meta property="og:site_name" content="üê∂ Dog with a Dev Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-11-24T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="I Can‚Äôt ai-rizz on Command" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Texarkanine"},"dateModified":"2025-11-24T00:00:00+00:00","datePublished":"2025-11-24T00:00:00+00:00","description":"Cursor introduced ‚ÄúSlash Commands‚Äù fairly recently, in v1.6 in September 2025. Claude Code had had a similar thing - Agent Skills - for a long time.","headline":"I Can‚Äôt ai-rizz on Command","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.cani.ne.jp/2025/11/24/cant-ai-rizz-on-command.html"},"url":"https://blog.cani.ne.jp/2025/11/24/cant-ai-rizz-on-command.html"}</script>
<!-- End Jekyll SEO tag -->
<link type="application/atom+xml" rel="alternate" href="https://blog.cani.ne.jp/feed.xml" title="üê∂ Dog with a Dev Blog" /><link rel="shortcut icon" type="image/x-icon" href="" />
  <link rel="stylesheet" href="/assets/css/main.css" />
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.css" integrity="sha384-OH8qNTHoMMVNVcKdKewlipV4SErXqccxxlg6HC9Cwjr5oZu2AdBej1TndeCirael" crossorigin="anonymous">

</head>
<body a="light">
    <main class="page-content" aria-label="Content">
      <div class="w">
        




<p>
	<a href="/">~</a>
	
		/ <a href="/all-posts.html">..</a>
	
</p>
<header>
  <h1>I Can't ai-rizz on Command</h1>
  
  <div style="display: flex; justify-content: space-between; align-items: center;">
    <div>
      
      
      
      
      
      <span>
        a <a href="/categories/diary/">diary</a>
      </span>
      
      
      
      <span>
        by <a href="/authors/texarkanine/">texarkanine</a>
      </span>
      
    </div>
    <div>
      <span class="post-meta">2025-11-24</span>
    </div>
  </div>
</header>

<article>
  <p>Cursor introduced ‚Äú<a href="https://cursor.com/docs/agent/chat/commands" target="_blank" rel="noopener noreferrer">Slash Commands</a>‚Äù fairly recently, in v1.6 in September 2025. Claude Code had had a similar thing - <a href="https://code.claude.com/docs/en/skills" target="_blank" rel="noopener noreferrer">Agent Skills</a> - for a long time.</p>

<p>I recently saw Cursor add ‚ÄúTeam Commands‚Äù for enterprise accounts and got excited to finally leverage the power of Claude‚Äôs Agent Skills, but in Cursor for my team.</p>

<p>I blew the rest of my prepaid Cursor usage on trying to add Cursor Command support to <a href="https://github.com/texarkanine/ai-rizz" target="_blank" rel="noopener noreferrer">ai-rizz</a>, but hit two snags:</p>

<h2 id="commands-just-aint-rules">Commands Just Ain‚Äôt Rules</h2>

<h3 id="directory-structure-is-part-of-the-command">Directory Structure is Part of the Command</h3>

<p>A Cursor Command located in <code class="language-plaintext highlighter-rouge">./cursor/commands/foo.md</code> can be triggered by typing <code class="language-plaintext highlighter-rouge">/foo</code>.</p>

<p>A Cursor Command located in <code class="language-plaintext highlighter-rouge">./cursor/commands/foo/bar.md</code> can be triggered by typing <code class="language-plaintext highlighter-rouge">/foo/bar</code></p>

<p>This meant that the pattern <code class="language-plaintext highlighter-rouge">ai-rizz</code> used to ensure its managed rules stayed separate from other rules, of ‚Äúclaiming‚Äù two subdirectories of the <code class="language-plaintext highlighter-rouge">.cursor/rules</code> directory for itself:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.cursor/rules
‚îú‚îÄ‚îÄ local
‚îÇ   ‚îî‚îÄ‚îÄ my-local-rule.mdc
‚îî‚îÄ‚îÄ shared
    ‚îî‚îÄ‚îÄ my-shared-rule.mdc
</code></pre></div></div>

<p>wouldn‚Äôt work. The commands became unnecessarily prefixed with junk.</p>

<p>So, they really needed to go in <code class="language-plaintext highlighter-rouge">.cursor/commands/*.md</code> directly.</p>

<p>I came up with an idea, though: We‚Äôd store them in <code class="language-plaintext highlighter-rouge">.cursor/shared-commands</code>, and symlink them into <code class="language-plaintext highlighter-rouge">.cursor/commands</code>. This allowed prefix-less use of the commands but also kept the managed commands easily-identifiable - all symlinks in <code class="language-plaintext highlighter-rouge">.cursor/commands</code> to <code class="language-plaintext highlighter-rouge">.cursor/shared-commands/*.md</code> were managed, and all other commands weren‚Äôt.</p>

<h3 id="tracking">Tracking</h3>

<p>Clever design in <code class="language-plaintext highlighter-rouge">ai-rizz</code> makes keeping track of rules‚Äô provenance easy: simply knowing a rule‚Äôs path on disk is enough to know if it should be in source control, whether it should be ignored, or whether it‚Äôs a ‚Äúuser‚Äù rule not managed by <code class="language-plaintext highlighter-rouge">ai-rizz</code>.</p>

<p>This is only manageable because the <code class="language-plaintext highlighter-rouge">.cursor/rules/local</code> directory is ignored by git with a single <code class="language-plaintext highlighter-rouge">.git/info/exclude</code> entry - one configuration line and you can put <em>all</em> rules you need in <code class="language-plaintext highlighter-rouge">local</code> and they‚Äôre all untracked. You put all the tracked ones in <code class="language-plaintext highlighter-rouge">shared</code>, and any other directory tree is user rules.</p>

<p>What if we tried to find that semantic for symlinks in <code class="language-plaintext highlighter-rouge">.cursor/commands/</code>, though?</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">.cursor/commands/local-cmd.md.lnk</code> -&gt; should not be committed</li>
  <li>
<code class="language-plaintext highlighter-rouge">.cursor/commands/committed-cmd.md.lnk</code> -&gt; should be committed</li>
  <li>
<code class="language-plaintext highlighter-rouge">.cursor/commands/actual-cmd.md</code> -&gt; user command, should not be touched</li>
</ul>

<p>Now we have to read &amp; write exhaustive git ignore specs that identify every local command. Moreover, with rules, simply knowing a rule‚Äôs path on disk was enough to know if it was a local, committed, or user rule. With commands all in one directory, you have to read the <code class="language-plaintext highlighter-rouge">ai-rizz</code> manifest each time to figure out the semantic for a given command. That‚Äôs a lot of bookkeeping and opportunity to go wrong.</p>

<p>I came up with a solution I thought could work: Declare that commands are commit-only in a repo. Tell the user to go set up <code class="language-plaintext highlighter-rouge">ai-rizz</code> in their user directory and have it manage <code class="language-plaintext highlighter-rouge">~/.cursor/commands</code> (this works) for commands that will live on their machine and not in the repo. Yes, the commands <em>would</em> become available to all repos, but that is primarily what I find myself doing with local <em>rules</em>, anyway - I pull the same set of customizations into every repo I work with, in ‚Äúlocal‚Äù mode. If they could be ‚Äúglobal‚Äù to my local machine, that would be handy!</p>

<h3 id="promotion">Promotion</h3>

<p><code class="language-plaintext highlighter-rouge">ai-rizz</code> can store <em>rules</em> with or without git tracking in a repository. You can try them out locally, and the ones that work really well with the repository get <strong>promoted</strong> to being committed to source control.</p>

<p>What does ‚Äúpromotion‚Äù look like for Commands?</p>

<p>First of all, the promotion semantic is inverted for commands: A command might be committed to one repo at first, and then you might really find it useful and want to promote it to <strong>all</strong> repos. So it goes from ‚Äúcommit‚Äù to ‚Äúlocal‚Äù (which is really ‚Äúglobal,‚Äù as we‚Äôll see‚Ä¶)</p>

<p>With that semantic and my ideas for command management so far, the existing code would do a very wrong thing: Promoting a command would pull it <strong>out</strong> of a repository and into the user‚Äôs home directory. That‚Äôs only correct if development is entirely by one user on one machine. Otherwise, when the user promotes their command they‚Äôll commit and push the repo without the command in it and now their colleagues will lose access to that command! That‚Äôs the <em>opposite</em> of what <code class="language-plaintext highlighter-rouge">ai-rizz</code> is supposed to facilitate!</p>

<p>So, flip the semantic, right? Commands <em>start</em> in <code class="language-plaintext highlighter-rouge">~/.cursor/commands</code>, and you commit them to a repo <strong>iff you like them!</strong> Done that way, a command starts out available in <em>every</em> repository, not the one you‚Äôre working with at the moment. Weird but probably harmless.</p>

<p>But then when you like the command and ‚Äúpromote‚Äù it to be committed to the repo so that everyone who works with the repo gets it, it gets pulled out of your user home and now the rest of <em>your</em> repositories lose access to it!</p>

<p><strong>There‚Äôs just no sensible promotion semantic for Commands:</strong> You have to allow duplication, where promotion <em>copies</em> it to <code class="language-plaintext highlighter-rouge">~/.cursor/commands</code> but also keeps it in each repo it was added to.</p>

<p>And that meant that</p>

<ol>
  <li>I wouldn‚Äôt be able to re-use much of <code class="language-plaintext highlighter-rouge">ai-rizz</code>‚Äôs rules codebase for commands</li>
  <li>Users of <code class="language-plaintext highlighter-rouge">ai-rizz</code> would have to maintain two very different mental models</li>
</ol>

<h2 id="what-are-they-for-anyway">What Are They For, Anyway?</h2>

<p>While I was stewing over how to possibly make this work, I had an epiphany: <strong>I don‚Äôt have a use-case for Cursor Commands, anway!</strong>
You can go read about why, <a href="/2025/11/24/usent-case-for-ai-coding-agent-slash-commands.html">here</a>.</p>

</article>

<footer>
  
  
  <p>
    tagged: 
    
      <a href="/tags/cursor/">cursor</a>, 
    
      <a href="/tags/ai/">ai</a>, 
    
      <a href="/tags/claude-code/">claude-code</a>
    
  </p>
  
</footer>




<p>
	<a href="/">~</a>
	
		/ <a href="/all-posts.html">..</a>
	
</p>

      </div>
    </main>
  </body>
</html>