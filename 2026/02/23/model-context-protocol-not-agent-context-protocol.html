<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <title>It's Model Context Protocol, Not Agent Context Protocol</title>
<!-- Begin Jekyll SEO tag v2.8.0 --> <meta name="generator" content="Jekyll v4.4.1"> <meta property="og:title" content="It‚Äôs Model Context Protocol, Not Agent Context Protocol"> <meta name="author" content="Texarkanine"> <meta property="og:locale" content="en_US"> <meta name="description" content="Thesis"> <meta property="og:description" content="Thesis"> <link rel="canonical" href="https://blog.cani.ne.jp/2026/02/23/model-context-protocol-not-agent-context-protocol.html"> <meta property="og:url" content="https://blog.cani.ne.jp/2026/02/23/model-context-protocol-not-agent-context-protocol.html"> <meta property="og:site_name" content="üê∂ Dog with a Dev Blog"> <meta property="og:type" content="article"> <meta property="article:published_time" content="2026-02-23T00:00:00+00:00"> <meta name="twitter:card" content="summary"> <meta property="twitter:title" content="It‚Äôs Model Context Protocol, Not Agent Context Protocol"> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Texarkanine"},"dateModified":"2026-02-23T00:00:00+00:00","datePublished":"2026-02-23T00:00:00+00:00","description":"Thesis","headline":"It‚Äôs Model Context Protocol, Not Agent Context Protocol","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.cani.ne.jp/2026/02/23/model-context-protocol-not-agent-context-protocol.html"},"url":"https://blog.cani.ne.jp/2026/02/23/model-context-protocol-not-agent-context-protocol.html"}</script> <!-- End Jekyll SEO tag --> <link type="application/atom+xml" rel="alternate" href="https://blog.cani.ne.jp/feed.xml" title="üê∂ Dog with a Dev Blog">
<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.css" integrity="sha384-OH8qNTHoMMVNVcKdKewlipV4SErXqccxxlg6HC9Cwjr5oZu2AdBej1TndeCirael" crossorigin="anonymous"> </head> <body a="light"> <main class="page-content" aria-label="Content"> <div class="w"> <p> <a href="/">~</a> / <a href="/all-posts.html">..</a> </p> <header> <h1>It's Model Context Protocol, Not Agent Context Protocol</h1> <div style="display: flex; justify-content: space-between; align-items: center;"> <div> <span> an <a href="/categories/essay/">essay</a> </span> <span> by <a href="/authors/texarkanine/">texarkanine</a> </span> </div> <div> <span class="post-meta">2026-02-23</span> </div> </div> </header> <article> <h2 id="thesis">Thesis</h2> <blockquote> <p>Most of the time, MCP doesn‚Äôt deliver any value beyond what a capable model could get from a CLI and a shell.</p> </blockquote> <h2 id="the-m">The M</h2> <p>The ‚ÄúM‚Äù in <a href="https://modelcontextprotocol.io" target="_blank" rel="noopener">MCP</a> stands for ‚ÄúModel.‚Äù Not ‚ÄúAgent.‚Äù</p> <p>That single letter does a remarkable amount of work if you let it. A <em>model</em> - in the MCP sense - is an LLM with a narrow task, deployed for a specific kind of processing. An <em>agent</em> - as the industry has been using the term - is a general-purpose thinker given latitude to figure things out.</p> <p>MCP was designed to give <em>‚Äúmodels‚Äù</em> with constrained reasoning capabilities well-defined tools that they could find and use to succeed. Somewhere along the way, people started bolting it onto <em>agents</em> and wondering why the fit was bad.</p> <h2 id="the-baseline-is-free">The Baseline Is Free</h2> <p>A sufficiently capable model with shell access can already do a lot. It knows <a href="https://cli.github.com/" target="_blank" rel="noopener">gh</a>. It knows <a href="https://curl.se/" target="_blank" rel="noopener">curl</a>. It knows <a href="https://jqlang.org/" target="_blank" rel="noopener">jq</a>. It can read <code class="language-plaintext highlighter-rouge">--help</code>. It can try things, observe the output, and adjust. This is the baseline, and the baseline is free - no tool definitions in context, no server overhead, no configuration to manage.</p> <p>MCP has to beat free.</p> <p>Everything MCP puts into a model‚Äôs context window has a cost: tokens for the tool definitions, tokens for the schemas, attention spent considering tools that may not be relevant to the task at hand. If you‚Äôve read ‚Äú<a href="/2026/02/12/stop-doing-agents-md.html">Stop Doing AGENTS.md</a>‚Äù, you already know where I stand on paying context rent for things that aren‚Äôt pulling their weight. MCP is no different. A tool definition sitting in context is overhead until the moment it‚Äôs invoked - and if the model <em>might not</em> invoke it, you‚Äôre speculating with your context budget.</p> <p>So the question for any MCP integration is: what does this buy me that the model couldn‚Äôt get on its own?</p> <h2 id="earning-tokens">Earning Tokens</h2> <p>There are a handful of things MCP genuinely buys over the baseline. Each one is a mechanism that justifies the context cost - but only when the tool is <em>core</em> to the model‚Äôs task.</p> <h3 id="attention">Attention</h3> <p>When a tool is always in context, the model always knows it exists and exactly how to call it. No discovery step, no hoping it ‚Äúremembers‚Äù that some CLI is available, no wasted attempt with wrong flags.</p> <p>For a narrow-task model that <em>will</em> use this tool on every invocation, that‚Äôs not overhead - that‚Äôs the job description. Your customer service agent that files tickets? It should have the ticketing tool in context, always. That‚Äôs what it <em>does</em>.</p> <p>For a general-purpose coding agent that <em>might</em> use it? You‚Äôre paying rent on a room nobody‚Äôs sleeping in.</p> <h3 id="formatting">Formatting</h3> <p>The strict I/O contract of an MCP server‚Äôs tool invocation solves two problems:</p> <ol> <li>‚ÄúComplex, error-sensitive output formats are easier for LLMs to get wrong than freeform prose‚Äù</li> <li>‚ÄúThe consequences of wrong output are severe‚Äù</li> </ol> <p>Do you even have those problems? The value is proportional to how bad the failure mode is.</p> <p>A CSR agent accidentally malforming a deletion request and nuking the wrong entity is catastrophic. A coding agent producing slightly wonky JSON in a one-off script is a minor annoyance you‚Äôll catch in review. MCP‚Äôs strict formatting buys you insurance, and insurance is only worth buying against risks that would actually hurt.</p> <h3 id="business-logic-and-sequencing">Business Logic and Sequencing</h3> <p>When primitive API operations must be composed in a strict order, you have business logic. Things like create the parent before the child, set the status before assigning the owner, ensure delivery of the last message before archiving, etc. You can write that logic into your prompt and hope the stochastic parrot doesn‚Äôt drop step 3 of 7, or you can encode it into a deterministic tool that gets it right every time.</p> <p>The MCP earns its tokens by encoding sequences that are easy to get wrong and expensive to debug.</p> <h3 id="auth-scope-management">Auth Scope Management</h3> <p>Maybe your API token has <code class="language-plaintext highlighter-rouge">delete</code> permissions, but you only want the model to be able to delete orphaned entities. Instead of just asking nicely and hoping for the best, an MCP server can expose the ‚Äúdelete orphaned entities‚Äù tool, and hold onto the API token. The LLM can‚Äôt mistakenly delete something it shouldn‚Äôt because it doesn‚Äôt actually have credentials to delete!</p> <p>You can also offload auth entirely, e.g. with web-based OAuth flows. MCP gives you granularity beyond what the underlying API offers.</p> <p>This is a real, concrete security win. Your L1 CSR agent gets N tools for its N tasks, and that‚Äôs <em>all</em> it can do. No <code class="language-plaintext highlighter-rouge">bash</code>, no <code class="language-plaintext highlighter-rouge">curl</code> - not just because those aren‚Äôt its job, but because injection and privilege escalation are real risks when a model has access to a shell and credentials in the same context. Block all <em>commands.</em> Give it the <em>tools.</em> Done.</p> <h3 id="parallelism">Parallelism</h3> <p>If you‚Äôre running a true, long-lived MCP server (not a per-invocation spawn) and you have multiple model instances hitting it concurrently, the server can handle synchronization. This is a real but minor benefit, and I‚Äôd argue that if your underlying API can‚Äôt handle concurrent access, that‚Äôs a different bug. MCP shouldn‚Äôt be your concurrency band-aid.</p> <h2 id="when-mcp-is-wrong">When MCP Is Wrong</h2> <p>The flip side falls out naturally:</p> <p><strong>There‚Äôs a clear CLI.</strong></p> <p><code class="language-plaintext highlighter-rouge">gh</code> exists. My coding agents don‚Äôt have the GitHub MCP and they don‚Äôt need it. The model already knows <code class="language-plaintext highlighter-rouge">gh</code> is there, and if it doesn‚Äôt, one failed attempt and a <code class="language-plaintext highlighter-rouge">--help</code> later, it does.</p> <p><strong>There‚Äôs a clean, well-documented API.</strong></p> <p>If the model can <code class="language-plaintext highlighter-rouge">curl</code> it and parse the response, you‚Äôre adding overhead for nothing by defining all the interactions in context before they‚Äôre needed. An agent can look up the API spec and <code class="language-plaintext highlighter-rouge">curl</code> into it when it needs to!</p> <p><strong>The tool is something the agent <em>might</em> need, not something it <em>will</em> need.</strong></p> <p>This is the crucial distinction. An always-in-context tool that gets used on 10% of interactions is a tax on the other 90%. The question to ask is:</p> <blockquote> <p>Is this a <em>core purpose</em> of the model, or is this a <em>capability</em> it <em>might</em> reach for?</p> </blockquote> <p>If the latter, it shouldn‚Äôt be an MCP tool.</p> <p>And here‚Äôs the big one:</p> <p><strong>General-purpose coding agents</strong></p> <p>MCP is probably wrong. Your coding agent‚Äôs job is to read code, write code, run commands, explore, and iterate. The set of ‚Äútools‚Äù it might need on any given task is enormous and unpredictable. Shoving a dozen MCPs into its context ‚Äújust in case‚Äù is exactly the antipattern - you‚Äôre paying context rent on tools the agent mostly won‚Äôt use, for tasks it could accomplish with the shell it already has. A small set of versatile, open-ended tools - by which I basically just mean file I/O operations and a shell (and maybe spawning a subagent) - is much better-suited to its job.</p> <h2 id="the-discourse">The Discourse</h2> <p>I‚Äôve seen an uptick in anti-MCP discourse lately - both explicit and implicit. For some examples:</p> <ul> <li>‚ÄúMCP is dead, just use the CLI‚Äù</li> <li>‚ÄúMCP is a context waste‚Äù</li> <li>
<a href="https://forum.cursor.com/t/return-the-custom-modes-features/144170/5?u=texarkanine" target="_blank" rel="noopener">Bring Back Cursor Modes</a>!</li> <li>A colleague of mine built a script to selectively set the contents of <code class="language-plaintext highlighter-rouge">mcp.json</code> before launching Claude Code</li> </ul> <p>They‚Äôre all tugging at real threads. The ‚ÄúMCP is dead‚Äù crowd correctly observes that general-purpose agents don‚Äôt benefit from MCP - or at least, it‚Äôs often a poor fit. The jugglers correctly observe that having all your MCPs loaded all the time is wasteful. The mode-switchers correctly observe that different tasks need different tool sets.</p> <p>But the juggling is a smell. If you need to dynamically swap which MCPs are loaded based on what you‚Äôre about to do, you‚Äôve built an agent-that-configures-agents, and the inner agent is still general-purpose. The right move wasn‚Äôt better juggling - it was narrower models with fewer, always-relevant tools.</p> <p>The M was the tell the whole time.</p> <h2 id="what-to-do">What To Do</h2> <h3 id="1-prune">1. Prune</h3> <p>Go look at your MCP configuration right now. For each server, ask: ‚ÄúDoes this earn its tokens?‚Äù Apply the framework above. If the model could accomplish the same thing with a CLI it already knows about, or a clean API it can <code class="language-plaintext highlighter-rouge">curl</code>, cut it.</p> <p>You‚Äôll probably end up keeping a few. The ones where auth is genuinely scoped down, where business logic is genuinely fragile, where the tool <em>is</em> the model‚Äôs core task. Good - those are the ones MCP was built for.</p> <p>But you‚Äôll also have a pile of useful-but-not-earning-it tools that you still want <em>available</em> sometimes. Set those aside. We‚Äôll come back to them.</p> <h3 id="2-pave-your-desire-paths">2. Pave Your Desire Paths</h3> <p>Before reaching for any context management technique, ask why the model needed the MCP server in the first place. Can it not <a href="https://github.com/sooperset/mcp-atlassian" target="_blank" rel="noopener">figure out how to interface with a gnarly remote service</a>? Can it not <a href="https://context7.com/" target="_blank" rel="noopener">find the information it needed</a>? Are you limited in how you can authenticate?</p> <p>How much of that can you just <em>write down</em>, succinctly, somewhere? Instead of installing the GitHub MCP, can you write</p> <blockquote> <p>‚Äúyou have the <code class="language-plaintext highlighter-rouge">gh</code> cli installed and authenticated, use it to interact with GitHub.‚Äù</p> </blockquote> <p>Instead of Context7, can you write</p> <blockquote> <p>‚ÄúAll of the dependencies‚Äô source code is present in the <code class="language-plaintext highlighter-rouge">node_modules/</code> directory; check there first for canonical information about how 3rd-party libraries are to be used.‚Äù</p> </blockquote> <p>Take it a step further: Is the model trying to look in the wrong place for information? Can you put the information there? Put the guidance where agents already look - <code class="language-plaintext highlighter-rouge">README.md</code>, <code class="language-plaintext highlighter-rouge">CONTRIBUTING.md</code>, the CLI‚Äôs own <code class="language-plaintext highlighter-rouge">--help</code> text. If models keep expecting something to exist and it reasonably could, can you just‚Ä¶ make it exist?</p> <p>The extreme case of this is <a href="https://www.holovaty.com/writing/chatgpt-fake-feature/" target="_blank" rel="noopener">Soundslice literally building a feature</a> because ChatGPT kept telling users it existed. You probably don‚Äôt need to go <em>that</em> far, but the principle is sound:</p> <blockquote> <p>the cheapest context is the context you never had to add because the model‚Äôs intuition was already correct.</p> </blockquote> <h3 id="3-recover-the-rest-as-skills">3. Recover the Rest as Skills</h3> <p>After pruning and paving, you‚Äôll still have tools that are genuinely useful but don‚Äôt earn always-in-context MCP weight. <a href="https://agentskills.io" target="_blank" rel="noopener">Agent Skills</a> are a mechanically better home for these, and here‚Äôs why: information hiding.</p> <p>An MCP server, once connected, dumps every tool definition into context. The model sees every operation it could perform against that service, whether it needs them or not. A skill sits in context as a one- or two-sentence description of what it offers and when it might be useful. The full content stays hidden until the model decides it needs it. Only then does it get pulled in. You still pay a small context tax, but it‚Äôs much more scalable.</p> <p>Daniel Miessler describes the appropriate technique well in his framing of <a href="https://danielmiessler.com/blog/when-to-use-skills-vs-commands-vs-agents" target="_blank" rel="noopener">skills as domain containers</a> - a skill is a self-contained domain of capability that the agent can reach for when relevant, rather than a firehose of tool definitions it has to wade through on every interaction.</p> <p>So instead of the GitHub MCP, consider a ‚Äúhow to interact with GitHub‚Äù skill. It starts by noting that the <code class="language-plaintext highlighter-rouge">gh</code> CLI is probably available and the agent should try that first. But if not, here‚Äôs GitHub‚Äôs REST API base URL and <a href="https://docs.github.com/en/rest/quickstart?apiVersion=2022-11-28" target="_blank" rel="noopener">docs</a>. For batch operations or complex stitching, here‚Äôs the <a href="https://docs.github.com/en/graphql/guides/introduction-to-graphql#discovering-the-graphql-api" target="_blank" rel="noopener">GraphQL API</a>. If you‚Äôre going to write code against it, here is the <a href="https://octokit.github.io/rest.js/v22/" target="_blank" rel="noopener">SDK</a> and how to install it. The agent gets <em>none</em> of this until it realizes it needs to talk to GitHub - and then it gets <em>all</em> of it, in a form that guides it toward the right approach for the specific sub-task rather than handing it a flat list of 50 MCP operations.</p> <p>Skills can also bundle standalone resources - scripts, templates, deterministic tooling, etc. Instead of writing a <em>prompt</em> describing how to form a correct <code class="language-plaintext highlighter-rouge">curl</code> to an API, you can just write a script that the agent can invoke, and bundle that in the skill. This can achieve the same reliability of outcomes that MCP delivered, but without the context tax.</p> <h3 id="4-wait-and-agitate">4. Wait, and Agitate</h3> <p>The <em>real</em> solution doesn‚Äôt exist yet.</p> <p>Despite some <a href="https://arxiv.org/abs/2408.16737" target="_blank" rel="noopener">interesting</a> emerging <a href="https://arxiv.org/abs/2501.05465v1" target="_blank" rel="noopener">research</a> suggesting that smaller models <a href="https://arxiv.org/abs/2510.03847" target="_blank" rel="noopener">can match or outperform</a> larger models when properly focused on specific tasks, no major harness actually lets you act on this.</p> <p>What we need is for the main agent to be able to spawn a subagent and kit it out with a specialized subset of tools (MCP <em>and</em> Skills!) that were <em>not</em> in the parent‚Äôs context. The parent would consult a menu of available tools when launching the subagent, select the relevant ones, and the subagent would get those tools - and <em>only</em> those tools - for its narrow task.</p> <p>Cursor Modes were the closest anyone got. They let you predefine sets of tools and context per mode, and if they‚Äôd <a href="https://forum.cursor.com/t/custom-agents-vs-code-cc-double-down-cursor-removes-its-own/145931" target="_blank" rel="noopener">persisted into the era of Cursor‚Äôs subagent maturity</a>, you could have had a harness that spawned subagents with specialized tool subsets not visible to the parent. But Cursor <a href="https://forum.cursor.com/t/return-the-custom-modes-features/144170" target="_blank" rel="noopener">removed Modes in 2.1</a>, and nothing has replaced them.</p> <p>Claude Code, the current leader in subagent tooling, has a similar limitation: <a href="https://code.claude.com/docs/en/mcp#scope-hierarchy-and-precedence" target="_blank" rel="noopener">hierarchical configuration loading</a> means that if an MCP is visible to the parent, it‚Äôs active and in context. You can‚Äôt build a <em>library</em> of MCP servers without filling your context window. Claude Code would need some hook into the subagent launch process that configures MCP only for the child - MCPs that the parent knew about but wasn‚Äôt paying context rent on.</p> <p>That‚Äôs a hard design problem. The parent has to know about those MCPs to provide them to subagents, but knowing about them means they‚Äôre in context. Skills are the best workaround we have today, but they‚Äôre a workaround. The real fix is a harness-level feature that nobody ships yet.</p> <p>If you‚Äôre building agentic tooling: this is a gap!</p> </article> <footer> <p> tagged: <a href="/tags/ai/">ai</a>, <a href="/tags/mcp/">mcp</a>, <a href="/tags/llm-context-management/">llm-context-management</a> </p> </footer> <p> <a href="/">~</a> / <a href="/all-posts.html">..</a> </p> </div> </main> <footer> <a href="bitcoin:PM8TJf1vjyABc9bzymdixNhP9CUCDWSM6QEx2WbSf9gtgodZMuEdKHDYumhCdqJSEVFPTtZ3wcZiYravDcCyX848MZ9TgcMoNteo71ardqbNMsJb4BNg" target="_blank" rel="noopener noreferrer" class="call-me-bip-me-if-you-need-to-reach-me" aria-label="Support Me: BIP47 Payment Code"></a> </footer> </body> </html>
